{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/package.json","hash":"c2a16fbde3fb46835304610052e3cc0afa3610d5","modified":1524792955921},{"_id":"themes/BlueLake/db.json","hash":"dfe8380263ace8fb180b4eb527e82db3e5a11978","modified":1524792956169},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"3e78b20edc66b153cb6b708734ad9aa5381266bc","modified":1515578009000},{"_id":"themes/BlueLake/LICENSE","hash":"3e191ca3f51efc111863c4941051291a696ef43e","modified":1515578009000},{"_id":"themes/BlueLake/languages/en.yml","hash":"88f4e4cffce5598f949192d7e76c863a0d409981","modified":1515578009000},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"83ee131065111147d20ec13c4634a27ee4fd541d","modified":1515578009000},{"_id":"themes/BlueLake/languages/tr.yml","hash":"1c623122f1ff7878595de6783bd83afc3a746373","modified":1515578009000},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"0755af57d92a07ecff0e327f78eb25b0623a5852","modified":1515578009000},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"61f419488d4a8f62c2b90ee766b6e68ba2e88bd7","modified":1515578009000},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"d9f90ef2c6b4d8c95d142d021a5f47dda8462715","modified":1515578009000},{"_id":"themes/BlueLake/languages/ko.yml","hash":"20c7df4087ee65d75e96f68c71fdb050eb63677f","modified":1515578009000},{"_id":"themes/BlueLake/layout/archive.jade","hash":"0497469c869f0ac28f150295dbddf6920e6582c1","modified":1515578009000},{"_id":"themes/BlueLake/layout/base.jade","hash":"2e65a06a499fbb67c72f8345d71222e40e9ef523","modified":1515578009000},{"_id":"themes/BlueLake/layout/category.jade","hash":"384e2e2588ecab3f518f03f11f2b052d3827fad8","modified":1515578009000},{"_id":"themes/BlueLake/layout/index.jade","hash":"ba1ea647af5c134b1a950638ea864663b29d4e22","modified":1515578009000},{"_id":"themes/BlueLake/layout/page.jade","hash":"7d2a48f6a902605fd6cfc237e3c2f9c02d76492e","modified":1515578009000},{"_id":"themes/BlueLake/layout/post.jade","hash":"3025e7e259d69551a35f17db3c3981aaa77fe7bc","modified":1515578009000},{"_id":"themes/BlueLake/layout/tag.jade","hash":"835da21846c730f0e3e344dc7e2e59154030b4f7","modified":1515578009000},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1515578009000},{"_id":"themes/BlueLake/source/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1515578009000},{"_id":"source/_posts/Android/Android获取打气筒的三种方式.md","hash":"48b1a0790633f715deba88229aee1bc9568d6ae3","modified":1524821402254},{"_id":"source/about/index.md","hash":"8a38952192012f94aeb8335770f8ec2643b20a7b","modified":1524738114098},{"_id":"source/_posts/Java/Java-泛型学习笔记.md","hash":"3748515a5b2fcf7ac5c49de183d5297ea6c55101","modified":1524811298331},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"af9a4a65eba65c5140921326f2b5cae9db5d7d28","modified":1515578009000},{"_id":"themes/BlueLake/_config.yml","hash":"8cdd4900e31c9851325ac838f5ebd1d141f72718","modified":1524821464361},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"25e28dc48c392a5d10db1ed0f8a5899598d643d5","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"dbc5c401f4d8aa80fe9e73423aadb8b8969f0b62","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"26ae121ecc5bbe351927dd273d58871f69454500","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"1c988c7e1f716036e428ee16b8005a7b1bfb33c7","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"28d79fbb9d8ecc5692d3063e439f16224188abac","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1515578009000},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"3e4141538285aef2bd019832ba62bafd094c6097","modified":1515578009000},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"082ae16dad18ada28913772675861d7230134bea","modified":1515578009000},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"ba43bd011d64cd86fa420677c9000d328f4f6114","modified":1515578009000},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"f8ae55d5514fe493651ec04fbe73cb5fc482f7cd","modified":1515578009000},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"ff46afdedc1ab3c075ffed686b98f23aed066124","modified":1515578009000},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"a0309137277323f2fd61a3c6691e1bc51026f711","modified":1515578009000},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"3df9a00a21d3bc151026b2d403a99c28fe1ccd13","modified":1515578009000},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"53e99461ae7f8efb2a1e78ad3090dd93d18bcd5c","modified":1515578009000},{"_id":"themes/BlueLake/source/css/style.styl","hash":"5852cc541b74868e6464c7224b65683ea5aaa8d8","modified":1515578009000},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1515578009000},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"be9ad73454b7029311caafd8e1faa469a5d4f58d","modified":1515578009000},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"2b6a0b21bf63bdf746130117baf432fcb44ad210","modified":1515578009000},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1515578009000},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1515578009000},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1515578009000},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1515578009000},{"_id":"themes/BlueLake/source/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1515578009000},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1515578009000},{"_id":"source/_posts/others/工作随记-4月4周.md","hash":"03e2d47c65dd32fb4042cbff571d27dfc7c0be29","modified":1524816298617},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"52e4cacd58d5e0061924189ad75e0c3bf622aa7f","modified":1515578009000},{"_id":"public/content.json","hash":"9ced35953987abb92093cd7fddea7bddaa530663","modified":1525740869426},{"_id":"public/about/index.html","hash":"60241a9315d1d27cc7f0f254fff9e8dc644cad08","modified":1525740869430},{"_id":"public/2018/04/27/Android/Android获取打气筒的三种方式/index.html","hash":"58a7fa28345ff76b842846b4c476c824cfa87315","modified":1525740869430},{"_id":"public/2018/04/27/others/工作随记-4月4周/index.html","hash":"8e3058efc8a1300511cbcd9136a63cad6be79d87","modified":1525740869431},{"_id":"public/archives/index.html","hash":"13537596178b59531025ec7c1f69d62a2b3263af","modified":1525740869431},{"_id":"public/archives/2018/index.html","hash":"13537596178b59531025ec7c1f69d62a2b3263af","modified":1525740869431},{"_id":"public/archives/2018/04/index.html","hash":"13537596178b59531025ec7c1f69d62a2b3263af","modified":1525740869431},{"_id":"public/index.html","hash":"e6f00e0d9aa7224ecf1942248aa203b5e2fcd740","modified":1525740869431},{"_id":"public/categories/安卓/index.html","hash":"28a2c5f8ef713ee5c3e9b4f5d4e194def047a835","modified":1525740869431},{"_id":"public/categories/Java/index.html","hash":"5949c5701ca5e65232a11bfd2a02f1e9311d683f","modified":1525740869431},{"_id":"public/categories/工作/index.html","hash":"6fadf556c722ca6dc4cc1af5b3aac9dfad73caf7","modified":1525740869431},{"_id":"public/tags/java/index.html","hash":"f3e794ea4281467d44eb0b0b85aed687bde91fc9","modified":1525740869431},{"_id":"public/2018/04/27/Java/Java-泛型学习笔记/index.html","hash":"b1e1f8c4481d1a3b145b7e95b2b579dba3cf3d95","modified":1525740869431},{"_id":"public/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1525740869433},{"_id":"public/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1525740869433},{"_id":"public/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1525740869433},{"_id":"public/iconfont/iconfont.svg","hash":"2b6a0b21bf63bdf746130117baf432fcb44ad210","modified":1525740869434},{"_id":"public/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1525740869434},{"_id":"public/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1525740869434},{"_id":"public/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1525740869940},{"_id":"public/css/highlight.css","hash":"932879716cbce6f9a1b830070ed514082398f1ca","modified":1525740869942},{"_id":"public/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1525740869942},{"_id":"public/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1525740869942},{"_id":"public/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1525740869942},{"_id":"public/css/style.css","hash":"45a02c24123d7107ed700c695506d5ef7c274fc1","modified":1525740869942}],"Category":[{"name":"安卓","_id":"cjgwypwx90003os6x8davowm7"},{"name":"Java","_id":"cjgwypwxb0005os6xuehnyg1c"},{"name":"工作","_id":"cjgwypwxf000aos6xtw0857sd"}],"Data":[],"Page":[{"title":"about","date":"2018-04-26T10:21:54.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-04-26 18:21:54\n---\n","updated":"2018-04-26T10:21:54.098Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjgwypwx60001os6xkijx2fzw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Android获取打气筒的三种方式","date":"2018-04-27T08:06:00.000Z","_content":"\n## 什么是打气筒？\n\n把我们自己定义的布局转换成一个view对象，就会用到打气筒\n\n## Android中获取打气筒的三种方式\n\n- view = View.inflate(getApplicationContext(), R.layout.item, null);\n- view = LayoutInflater.from(getApplicationContext()).inflate(R.layout.item, null);  \n- LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);  \n                view = inflater.inflate(R.layout.item, null);  ","source":"_posts/Android/Android获取打气筒的三种方式.md","raw":"---\ntitle: Android获取打气筒的三种方式\ndate: 2018-04-27 16:06\ntags: \ncategories:\n    - 安卓\n---\n\n## 什么是打气筒？\n\n把我们自己定义的布局转换成一个view对象，就会用到打气筒\n\n## Android中获取打气筒的三种方式\n\n- view = View.inflate(getApplicationContext(), R.layout.item, null);\n- view = LayoutInflater.from(getApplicationContext()).inflate(R.layout.item, null);  \n- LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);  \n                view = inflater.inflate(R.layout.item, null);  ","slug":"Android/Android获取打气筒的三种方式","published":1,"updated":"2018-04-27T09:30:02.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgwypwx20000os6xk44pb70x","content":"<h2 id=\"什么是打气筒？\"><a href=\"#什么是打气筒？\" class=\"headerlink\" title=\"什么是打气筒？\"></a>什么是打气筒？</h2><p>把我们自己定义的布局转换成一个view对象，就会用到打气筒</p>\n<h2 id=\"Android中获取打气筒的三种方式\"><a href=\"#Android中获取打气筒的三种方式\" class=\"headerlink\" title=\"Android中获取打气筒的三种方式\"></a>Android中获取打气筒的三种方式</h2><ul>\n<li>view = View.inflate(getApplicationContext(), R.layout.item, null);</li>\n<li>view = LayoutInflater.from(getApplicationContext()).inflate(R.layout.item, null);  </li>\n<li>LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);  <pre><code>view = inflater.inflate(R.layout.item, null);  \n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是打气筒？\"><a href=\"#什么是打气筒？\" class=\"headerlink\" title=\"什么是打气筒？\"></a>什么是打气筒？</h2><p>把我们自己定义的布局转换成一个view对象，就会用到打气筒</p>\n<h2 id=\"Android中获取打气筒的三种方式\"><a href=\"#Android中获取打气筒的三种方式\" class=\"headerlink\" title=\"Android中获取打气筒的三种方式\"></a>Android中获取打气筒的三种方式</h2><ul>\n<li>view = View.inflate(getApplicationContext(), R.layout.item, null);</li>\n<li>view = LayoutInflater.from(getApplicationContext()).inflate(R.layout.item, null);  </li>\n<li>LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);  <pre><code>view = inflater.inflate(R.layout.item, null);  \n</code></pre></li>\n</ul>\n"},{"title":"Java 泛型学习笔记","date":"2018-04-27T05:35:51.000Z","_content":"\n## 一、什么是泛型？\n\n> 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。\n\n> 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n## 二、泛型特性\n\n泛型只在编译阶段有效。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。\n\n**对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**\n\n## 三、泛型的使用\n\n泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法\n\n### 3.1 泛型类\n\n通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。\n```\nclass 类名称 <泛型标识：可以随便写任意标识号，标识指定的泛型的类型>{\n  private 泛型标识 /*（成员变量类型）*/ var; \n  .....\n\n  }\n}\n```\n一个简单的泛型类：\n```\n//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\n//在实例化泛型类时，必须指定T的具体类型\npublic class Generic<T>{ \n    //key这个成员变量的类型为T,T的类型由外部指定  \n    private T key;\n\n    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定\n        this.key = key;\n    }\n\n    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定\n        return key;\n    }\n}\n```\n使用：\n```\n//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型\n//传入的实参类型需与泛型的类型参数类型相同，即为Integer.\nGeneric<Integer> genericInteger = new Generic<Integer>(123456);\n\n//传入的实参类型需与泛型的类型参数类型相同，即为String.\nGeneric<String> genericString = new Generic<String>(\"key_vlaue\");\nLog.d(\"泛型测试\",\"key is \" + genericInteger.getKey());\nLog.d(\"泛型测试\",\"key is \" + genericString.getKey());\n```\n**注意：**\n\n 1. 泛型的类型参数只能是类类型，不能是简单类型。\n 2. 不能对确切的泛型类型使用instanceof操作。\n\n### 3.2 泛型接口\n泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中\n```\n//定义一个泛型接口\npublic interface Generator<T> {\n    public T next();\n}\n```\n当实现泛型接口的类，未传入泛型实参时：\n```\n/**\n * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中\n * 即：class FruitGenerator<T> implements Generator<T>\n * 如果不声明泛型，如：class FruitGenerator implements Generator<T>，编译器会报错：\"Unknown class\"\n */\nclass FruitGenerator<T> implements Generator<T>{\n    @Override\n    public T next() {\n        return null;\n    }\n}\n```\n当实现泛型接口的类，传入泛型实参时：\n```\n/**\n * 传入泛型实参时：\n * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator<T>\n * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。\n * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型\n * 即：Generator<T>，public T next();中的的T都要替换成传入的String类型。\n */\npublic class FruitGenerator implements Generator<String> {\n\n    private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"};\n\n    @Override\n    public String next() {\n        Random rand = new Random();\n        return fruits[rand.nextInt(3)];\n    }\n}\n```\n\n### 3.3 泛型通配符\n\n**同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的**\n```\npublic void showKeyValue1(Generic<?> obj){\n    Log.d(\"泛型测试\",\"key value is \" + obj.getKey());\n}\n```\n类型通配符一般是使用？代替具体的**类型实参**，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。\n\n可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。\n\n### 3.4 泛型方法\n\n泛型方法比上面提到的泛型类要复杂的多\n\n需要注意的是：**泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。**\n```\n/**\n * 泛型方法的基本介绍\n * @param tClass 传入的泛型实参\n * @return T 返回值为T类型\n * 说明：\n *     1）public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法。\n *     2）只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。\n *     3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。\n *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。\n */\npublic <T> T genericMethod(Class<T> tClass)throws InstantiationException ,\n  IllegalAccessException{\n        T instance = tClass.newInstance();\n        return instance;\n}\n```\n```\nObject obj = genericMethod(Class.forName(\"com.test.test\"));\n```\n\n#### 3.4.1 泛型方法的基本使用\n\n```\npublic class GenericTest {\n   //这个类是个泛型类，在上面已经介绍过\n   public class Generic<T>{     \n        private T key;\n\n        public Generic(T key) {\n            this.key = key;\n        }\n\n        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。\n        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。\n        //所以在这个方法中才可以继续使用 T 这个泛型。\n        public T getKey(){\n            return key;\n        }\n\n        /**\n         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息\"cannot reslove symbol E\"\n         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。\n        public E setKey(E key){\n             this.key = keu\n        }\n        */\n    }\n\n    /** \n     * 这才是一个真正的泛型方法。\n     * 首先在public与返回值之间的<T>必不可少，这表明这是一个泛型方法，并且声明了一个泛型T\n     * 这个T可以出现在这个泛型方法的任意位置.\n     * 泛型的数量也可以为任意多个 \n     *    如：public <T,K> K showKeyName(Generic<T> container){\n     *        ...\n     *        }\n     */\n    public <T> T showKeyName(Generic<T> container){\n        System.out.println(\"container key :\" + container.getKey());\n        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。\n        T test = container.getKey();\n        return test;\n    }\n\n    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic<Number>这个泛型类做形参而已。\n    public void showKeyValue1(Generic<Number> obj){\n        Log.d(\"泛型测试\",\"key value is \" + obj.getKey());\n    }\n\n    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?\n    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类\n    public void showKeyValue2(Generic<?> obj){\n        Log.d(\"泛型测试\",\"key value is \" + obj.getKey());\n    }\n\n     /**\n     * 这个方法是有问题的，编译器会为我们提示错误信息：\"UnKnown class 'E' \"\n     * 虽然我们声明了<T>,也表明了这是一个可以处理泛型的类型的泛型方法。\n     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。\n    public <T> T showKeyName(Generic<E> container){\n        ...\n    }  \n    */\n\n    /**\n     * 这个方法也是有问题的，编译器会为我们提示错误信息：\"UnKnown class 'T' \"\n     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。\n     * 所以这也不是一个正确的泛型方法声明。\n    public void showkey(T genericObj){\n\n    }\n    */\n\n    public static void main(String[] args) {\n\n\n    }\n}\n```\n\n#### 3.4.2 类中的泛型方法\n\n泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，如下：\n```\npublic class GenericFruit {\n    class Fruit{\n        @Override\n        public String toString() {\n            return \"fruit\";\n        }\n    }\n\n    class Apple extends Fruit{\n        @Override\n        public String toString() {\n            return \"apple\";\n        }\n    }\n\n    class Person{\n        @Override\n        public String toString() {\n            return \"Person\";\n        }\n    }\n\n    class GenerateTest<T>{\n        public void show_1(T t){\n            System.out.println(t.toString());\n        }\n\n        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。\n        //由于泛型方法在声明的时候会声明泛型<E>，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。\n        public <E> void show_3(E t){\n            System.out.println(t.toString());\n        }\n\n        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。\n        public <T> void show_2(T t){\n            System.out.println(t.toString());\n        }\n    }\n\n    public static void main(String[] args) {\n        Apple apple = new Apple();\n        Person person = new Person();\n\n        GenerateTest<Fruit> generateTest = new GenerateTest<Fruit>();\n        //apple是Fruit的子类，所以这里可以\n        generateTest.show_1(apple);\n        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person\n        //generateTest.show_1(person);\n\n        //使用这两个方法都可以成功\n        generateTest.show_2(apple);\n        generateTest.show_2(person);\n\n        //使用这两个方法也都可以成功\n        generateTest.show_3(apple);\n        generateTest.show_3(person);\n    }\n}\n```\n\n#### 3.4.3 泛型方法与可变参数\n\n```\npublic <T> void printMsg( T... args){\n    for(T t : args){\n        Log.d(\"泛型测试\",\"t is \" + t);\n    }\n}\n//...\nprintMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55);\n```\n\n#### 3.4.4 静态方法与泛型\n\n注意：**静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。**\n\n即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。\n```\npublic class StaticGenerator<T> {\n    ....\n    ....\n    /**\n     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）\n     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。\n     * 如：public static void show(T t){..},此时编译器会提示错误信息：\n          \"StaticGenerator cannot be refrenced from static context\"\n     */\n    public static <T> void show(T t){\n\n    }\n}\n```\n\n#### 3.4.5 泛型方法总结\n\n> 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。\n\n### 3.5 泛型上下边界\n\n在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。\n\n#### 为泛型添加上边界，即传入的类型实参必须是指定类型的子类型\n```\npublic void showKeyValue1(Generic<? extends Number> obj){\n    Log.d(\"泛型测试\",\"key value is \" + obj.getKey());\n}\n```\n```\nGeneric<String> generic1 = new Generic<String>(\"11111\");\nGeneric<Integer> generic2 = new Generic<Integer>(2222);\nGeneric<Float> generic3 = new Generic<Float>(2.4f);\nGeneric<Double> generic4 = new Generic<Double>(2.56);\n\n//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类\n//showKeyValue1(generic1);\n\nshowKeyValue1(generic2);\nshowKeyValue1(generic3);\nshowKeyValue1(generic4);\n```\n\n**泛型的上下边界添加，必须与泛型的声明在一起 。**\n\n### 3.6 泛型数组\n\nsun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。\n\n下面的这个例子是不可以的：\n```\nList<String>[] ls = new ArrayList<String>[10];  \n```\n而使用通配符创建泛型数组是可以的，如下面这个例子：\n```\nList<?>[] ls = new ArrayList<?>[10];  \n```\n下面的也行：\n```\nList<String>[] ls = new ArrayList[10];\n```\n[sun公司文档说明][1]\n```\nList<String>[] lsa = new List<String>[10]; // Not really allowed.    \nObject o = lsa;    \nObject[] oa = (Object[]) o;    \nList<Integer> li = new ArrayList<Integer>();    \nli.add(new Integer(3));    \noa[1] = li; // Unsound, but passes run time store check    \nString s = lsa[1].get(0); // Run-time error: ClassCastException.\n```\n> 这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。\n\n> 而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。\n\n下面采用通配符的方式是被允许的:**数组的类型不可以是类型变量**，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。\n```\nList<?>[] lsa = new List<?>[10]; // OK, array of unbounded wildcard type.    \nObject o = lsa;    \nObject[] oa = (Object[]) o;    \nList<Integer> li = new ArrayList<Integer>();    \nli.add(new Integer(3));    \noa[1] = li; // Correct.    \nInteger i = (Integer) lsa[1].get(0); // OK \n```\n\n----------\n\n[1]: http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html","source":"_posts/Java/Java-泛型学习笔记.md","raw":"---\ntitle: Java 泛型学习笔记\ndate: 2018-04-27 13:35:51\ntags: \n    - java\ncategories:\n    - Java\n---\n\n## 一、什么是泛型？\n\n> 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。\n\n> 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n## 二、泛型特性\n\n泛型只在编译阶段有效。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。\n\n**对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**\n\n## 三、泛型的使用\n\n泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法\n\n### 3.1 泛型类\n\n通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。\n```\nclass 类名称 <泛型标识：可以随便写任意标识号，标识指定的泛型的类型>{\n  private 泛型标识 /*（成员变量类型）*/ var; \n  .....\n\n  }\n}\n```\n一个简单的泛型类：\n```\n//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\n//在实例化泛型类时，必须指定T的具体类型\npublic class Generic<T>{ \n    //key这个成员变量的类型为T,T的类型由外部指定  \n    private T key;\n\n    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定\n        this.key = key;\n    }\n\n    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定\n        return key;\n    }\n}\n```\n使用：\n```\n//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型\n//传入的实参类型需与泛型的类型参数类型相同，即为Integer.\nGeneric<Integer> genericInteger = new Generic<Integer>(123456);\n\n//传入的实参类型需与泛型的类型参数类型相同，即为String.\nGeneric<String> genericString = new Generic<String>(\"key_vlaue\");\nLog.d(\"泛型测试\",\"key is \" + genericInteger.getKey());\nLog.d(\"泛型测试\",\"key is \" + genericString.getKey());\n```\n**注意：**\n\n 1. 泛型的类型参数只能是类类型，不能是简单类型。\n 2. 不能对确切的泛型类型使用instanceof操作。\n\n### 3.2 泛型接口\n泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中\n```\n//定义一个泛型接口\npublic interface Generator<T> {\n    public T next();\n}\n```\n当实现泛型接口的类，未传入泛型实参时：\n```\n/**\n * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中\n * 即：class FruitGenerator<T> implements Generator<T>\n * 如果不声明泛型，如：class FruitGenerator implements Generator<T>，编译器会报错：\"Unknown class\"\n */\nclass FruitGenerator<T> implements Generator<T>{\n    @Override\n    public T next() {\n        return null;\n    }\n}\n```\n当实现泛型接口的类，传入泛型实参时：\n```\n/**\n * 传入泛型实参时：\n * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator<T>\n * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。\n * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型\n * 即：Generator<T>，public T next();中的的T都要替换成传入的String类型。\n */\npublic class FruitGenerator implements Generator<String> {\n\n    private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"};\n\n    @Override\n    public String next() {\n        Random rand = new Random();\n        return fruits[rand.nextInt(3)];\n    }\n}\n```\n\n### 3.3 泛型通配符\n\n**同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的**\n```\npublic void showKeyValue1(Generic<?> obj){\n    Log.d(\"泛型测试\",\"key value is \" + obj.getKey());\n}\n```\n类型通配符一般是使用？代替具体的**类型实参**，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。\n\n可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。\n\n### 3.4 泛型方法\n\n泛型方法比上面提到的泛型类要复杂的多\n\n需要注意的是：**泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。**\n```\n/**\n * 泛型方法的基本介绍\n * @param tClass 传入的泛型实参\n * @return T 返回值为T类型\n * 说明：\n *     1）public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法。\n *     2）只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。\n *     3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。\n *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。\n */\npublic <T> T genericMethod(Class<T> tClass)throws InstantiationException ,\n  IllegalAccessException{\n        T instance = tClass.newInstance();\n        return instance;\n}\n```\n```\nObject obj = genericMethod(Class.forName(\"com.test.test\"));\n```\n\n#### 3.4.1 泛型方法的基本使用\n\n```\npublic class GenericTest {\n   //这个类是个泛型类，在上面已经介绍过\n   public class Generic<T>{     \n        private T key;\n\n        public Generic(T key) {\n            this.key = key;\n        }\n\n        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。\n        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。\n        //所以在这个方法中才可以继续使用 T 这个泛型。\n        public T getKey(){\n            return key;\n        }\n\n        /**\n         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息\"cannot reslove symbol E\"\n         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。\n        public E setKey(E key){\n             this.key = keu\n        }\n        */\n    }\n\n    /** \n     * 这才是一个真正的泛型方法。\n     * 首先在public与返回值之间的<T>必不可少，这表明这是一个泛型方法，并且声明了一个泛型T\n     * 这个T可以出现在这个泛型方法的任意位置.\n     * 泛型的数量也可以为任意多个 \n     *    如：public <T,K> K showKeyName(Generic<T> container){\n     *        ...\n     *        }\n     */\n    public <T> T showKeyName(Generic<T> container){\n        System.out.println(\"container key :\" + container.getKey());\n        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。\n        T test = container.getKey();\n        return test;\n    }\n\n    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic<Number>这个泛型类做形参而已。\n    public void showKeyValue1(Generic<Number> obj){\n        Log.d(\"泛型测试\",\"key value is \" + obj.getKey());\n    }\n\n    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?\n    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类\n    public void showKeyValue2(Generic<?> obj){\n        Log.d(\"泛型测试\",\"key value is \" + obj.getKey());\n    }\n\n     /**\n     * 这个方法是有问题的，编译器会为我们提示错误信息：\"UnKnown class 'E' \"\n     * 虽然我们声明了<T>,也表明了这是一个可以处理泛型的类型的泛型方法。\n     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。\n    public <T> T showKeyName(Generic<E> container){\n        ...\n    }  \n    */\n\n    /**\n     * 这个方法也是有问题的，编译器会为我们提示错误信息：\"UnKnown class 'T' \"\n     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。\n     * 所以这也不是一个正确的泛型方法声明。\n    public void showkey(T genericObj){\n\n    }\n    */\n\n    public static void main(String[] args) {\n\n\n    }\n}\n```\n\n#### 3.4.2 类中的泛型方法\n\n泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，如下：\n```\npublic class GenericFruit {\n    class Fruit{\n        @Override\n        public String toString() {\n            return \"fruit\";\n        }\n    }\n\n    class Apple extends Fruit{\n        @Override\n        public String toString() {\n            return \"apple\";\n        }\n    }\n\n    class Person{\n        @Override\n        public String toString() {\n            return \"Person\";\n        }\n    }\n\n    class GenerateTest<T>{\n        public void show_1(T t){\n            System.out.println(t.toString());\n        }\n\n        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。\n        //由于泛型方法在声明的时候会声明泛型<E>，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。\n        public <E> void show_3(E t){\n            System.out.println(t.toString());\n        }\n\n        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。\n        public <T> void show_2(T t){\n            System.out.println(t.toString());\n        }\n    }\n\n    public static void main(String[] args) {\n        Apple apple = new Apple();\n        Person person = new Person();\n\n        GenerateTest<Fruit> generateTest = new GenerateTest<Fruit>();\n        //apple是Fruit的子类，所以这里可以\n        generateTest.show_1(apple);\n        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person\n        //generateTest.show_1(person);\n\n        //使用这两个方法都可以成功\n        generateTest.show_2(apple);\n        generateTest.show_2(person);\n\n        //使用这两个方法也都可以成功\n        generateTest.show_3(apple);\n        generateTest.show_3(person);\n    }\n}\n```\n\n#### 3.4.3 泛型方法与可变参数\n\n```\npublic <T> void printMsg( T... args){\n    for(T t : args){\n        Log.d(\"泛型测试\",\"t is \" + t);\n    }\n}\n//...\nprintMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55);\n```\n\n#### 3.4.4 静态方法与泛型\n\n注意：**静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。**\n\n即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。\n```\npublic class StaticGenerator<T> {\n    ....\n    ....\n    /**\n     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）\n     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。\n     * 如：public static void show(T t){..},此时编译器会提示错误信息：\n          \"StaticGenerator cannot be refrenced from static context\"\n     */\n    public static <T> void show(T t){\n\n    }\n}\n```\n\n#### 3.4.5 泛型方法总结\n\n> 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。\n\n### 3.5 泛型上下边界\n\n在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。\n\n#### 为泛型添加上边界，即传入的类型实参必须是指定类型的子类型\n```\npublic void showKeyValue1(Generic<? extends Number> obj){\n    Log.d(\"泛型测试\",\"key value is \" + obj.getKey());\n}\n```\n```\nGeneric<String> generic1 = new Generic<String>(\"11111\");\nGeneric<Integer> generic2 = new Generic<Integer>(2222);\nGeneric<Float> generic3 = new Generic<Float>(2.4f);\nGeneric<Double> generic4 = new Generic<Double>(2.56);\n\n//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类\n//showKeyValue1(generic1);\n\nshowKeyValue1(generic2);\nshowKeyValue1(generic3);\nshowKeyValue1(generic4);\n```\n\n**泛型的上下边界添加，必须与泛型的声明在一起 。**\n\n### 3.6 泛型数组\n\nsun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。\n\n下面的这个例子是不可以的：\n```\nList<String>[] ls = new ArrayList<String>[10];  \n```\n而使用通配符创建泛型数组是可以的，如下面这个例子：\n```\nList<?>[] ls = new ArrayList<?>[10];  \n```\n下面的也行：\n```\nList<String>[] ls = new ArrayList[10];\n```\n[sun公司文档说明][1]\n```\nList<String>[] lsa = new List<String>[10]; // Not really allowed.    \nObject o = lsa;    \nObject[] oa = (Object[]) o;    \nList<Integer> li = new ArrayList<Integer>();    \nli.add(new Integer(3));    \noa[1] = li; // Unsound, but passes run time store check    \nString s = lsa[1].get(0); // Run-time error: ClassCastException.\n```\n> 这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。\n\n> 而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。\n\n下面采用通配符的方式是被允许的:**数组的类型不可以是类型变量**，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。\n```\nList<?>[] lsa = new List<?>[10]; // OK, array of unbounded wildcard type.    \nObject o = lsa;    \nObject[] oa = (Object[]) o;    \nList<Integer> li = new ArrayList<Integer>();    \nli.add(new Integer(3));    \noa[1] = li; // Correct.    \nInteger i = (Integer) lsa[1].get(0); // OK \n```\n\n----------\n\n[1]: http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html","slug":"Java/Java-泛型学习笔记","published":1,"updated":"2018-04-27T06:41:38.331Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgwypwx70002os6xqywzzyj8","content":"<h2 id=\"一、什么是泛型？\"><a href=\"#一、什么是泛型？\" class=\"headerlink\" title=\"一、什么是泛型？\"></a>一、什么是泛型？</h2><blockquote>\n<p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>\n</blockquote>\n<blockquote>\n<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>\n</blockquote>\n<h2 id=\"二、泛型特性\"><a href=\"#二、泛型特性\" class=\"headerlink\" title=\"二、泛型特性\"></a>二、泛型特性</h2><p>泛型只在编译阶段有效。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>\n<p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>\n<h2 id=\"三、泛型的使用\"><a href=\"#三、泛型的使用\" class=\"headerlink\" title=\"三、泛型的使用\"></a>三、泛型的使用</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>\n<h3 id=\"3-1-泛型类\"><a href=\"#3-1-泛型类\" class=\"headerlink\" title=\"3.1 泛型类\"></a>3.1 泛型类</h3><p>通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;</span><br><span class=\"line\">  private 泛型标识 /*（成员变量类型）*/ var; </span><br><span class=\"line\">  .....</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个简单的泛型类：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class=\"line\">//在实例化泛型类时，必须指定T的具体类型</span><br><span class=\"line\">public class Generic&lt;T&gt;&#123; </span><br><span class=\"line\">    //key这个成员变量的类型为T,T的类型由外部指定  </span><br><span class=\"line\">    private T key;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定</span><br><span class=\"line\">        this.key = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定</span><br><span class=\"line\">        return key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span><br><span class=\"line\">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span><br><span class=\"line\">Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</span><br><span class=\"line\"></span><br><span class=\"line\">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span><br><span class=\"line\">Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);</span><br><span class=\"line\">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());</span><br><span class=\"line\">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>泛型的类型参数只能是类类型，不能是简单类型。</li>\n<li>不能对确切的泛型类型使用instanceof操作。</li>\n</ol>\n<h3 id=\"3-2-泛型接口\"><a href=\"#3-2-泛型接口\" class=\"headerlink\" title=\"3.2 泛型接口\"></a>3.2 泛型接口</h3><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义一个泛型接口</span><br><span class=\"line\">public interface Generator&lt;T&gt; &#123;</span><br><span class=\"line\">    public T next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当实现泛型接口的类，未传入泛型实参时：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span><br><span class=\"line\"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;</span><br><span class=\"line\"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public T next() &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当实现泛型接口的类，传入泛型实参时：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 传入泛型实参时：</span><br><span class=\"line\"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span><br><span class=\"line\"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span><br><span class=\"line\"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span><br><span class=\"line\"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String next() &#123;</span><br><span class=\"line\">        Random rand = new Random();</span><br><span class=\"line\">        return fruits[rand.nextInt(3)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-3-泛型通配符\"><a href=\"#3-3-泛型通配符\" class=\"headerlink\" title=\"3.3 泛型通配符\"></a>3.3 泛型通配符</h3><p><strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;</span><br><span class=\"line\">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>类型通配符一般是使用？代替具体的<strong>类型实参</strong>，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p>\n<p>可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p>\n<h3 id=\"3-4-泛型方法\"><a href=\"#3-4-泛型方法\" class=\"headerlink\" title=\"3.4 泛型方法\"></a>3.4 泛型方法</h3><p>泛型方法比上面提到的泛型类要复杂的多</p>\n<p>需要注意的是：<strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 泛型方法的基本介绍</span><br><span class=\"line\"> * @param tClass 传入的泛型实参</span><br><span class=\"line\"> * @return T 返回值为T类型</span><br><span class=\"line\"> * 说明：</span><br><span class=\"line\"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span><br><span class=\"line\"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span><br><span class=\"line\"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span><br><span class=\"line\"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span><br><span class=\"line\"> */</span><br><span class=\"line\">public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,</span><br><span class=\"line\">  IllegalAccessException&#123;</span><br><span class=\"line\">        T instance = tClass.newInstance();</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = genericMethod(Class.forName(&quot;com.test.test&quot;));</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-4-1-泛型方法的基本使用\"><a href=\"#3-4-1-泛型方法的基本使用\" class=\"headerlink\" title=\"3.4.1 泛型方法的基本使用\"></a>3.4.1 泛型方法的基本使用</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GenericTest &#123;</span><br><span class=\"line\">   //这个类是个泛型类，在上面已经介绍过</span><br><span class=\"line\">   public class Generic&lt;T&gt;&#123;     </span><br><span class=\"line\">        private T key;</span><br><span class=\"line\"></span><br><span class=\"line\">        public Generic(T key) &#123;</span><br><span class=\"line\">            this.key = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span><br><span class=\"line\">        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span><br><span class=\"line\">        //所以在这个方法中才可以继续使用 T 这个泛型。</span><br><span class=\"line\">        public T getKey()&#123;</span><br><span class=\"line\">            return key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;</span><br><span class=\"line\">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span><br><span class=\"line\">        public E setKey(E key)&#123;</span><br><span class=\"line\">             this.key = keu</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        */</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /** </span><br><span class=\"line\">     * 这才是一个真正的泛型方法。</span><br><span class=\"line\">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span><br><span class=\"line\">     * 这个T可以出现在这个泛型方法的任意位置.</span><br><span class=\"line\">     * 泛型的数量也可以为任意多个 </span><br><span class=\"line\">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class=\"line\">     *        ...</span><br><span class=\"line\">     *        &#125;</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class=\"line\">        System.out.println(&quot;container key :&quot; + container.getKey());</span><br><span class=\"line\">        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span><br><span class=\"line\">        T test = container.getKey();</span><br><span class=\"line\">        return test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span><br><span class=\"line\">    public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</span><br><span class=\"line\">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span><br><span class=\"line\">    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span><br><span class=\"line\">    public void showKeyValue2(Generic&lt;?&gt; obj)&#123;</span><br><span class=\"line\">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     /**</span><br><span class=\"line\">     * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &apos;E&apos; &quot;</span><br><span class=\"line\">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span><br><span class=\"line\">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span><br><span class=\"line\">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    */</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &apos;T&apos; &quot;</span><br><span class=\"line\">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span><br><span class=\"line\">     * 所以这也不是一个正确的泛型方法声明。</span><br><span class=\"line\">    public void showkey(T genericObj)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    */</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-4-2-类中的泛型方法\"><a href=\"#3-4-2-类中的泛型方法\" class=\"headerlink\" title=\"3.4.2 类中的泛型方法\"></a>3.4.2 类中的泛型方法</h4><p>泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GenericFruit &#123;</span><br><span class=\"line\">    class Fruit&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;fruit&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Apple extends Fruit&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;apple&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Person&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;Person&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class GenerateTest&lt;T&gt;&#123;</span><br><span class=\"line\">        public void show_1(T t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span><br><span class=\"line\">        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span><br><span class=\"line\">        public &lt;E&gt; void show_3(E t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span><br><span class=\"line\">        public &lt;T&gt; void show_2(T t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Apple apple = new Apple();</span><br><span class=\"line\">        Person person = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();</span><br><span class=\"line\">        //apple是Fruit的子类，所以这里可以</span><br><span class=\"line\">        generateTest.show_1(apple);</span><br><span class=\"line\">        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span><br><span class=\"line\">        //generateTest.show_1(person);</span><br><span class=\"line\"></span><br><span class=\"line\">        //使用这两个方法都可以成功</span><br><span class=\"line\">        generateTest.show_2(apple);</span><br><span class=\"line\">        generateTest.show_2(person);</span><br><span class=\"line\"></span><br><span class=\"line\">        //使用这两个方法也都可以成功</span><br><span class=\"line\">        generateTest.show_3(apple);</span><br><span class=\"line\">        generateTest.show_3(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-4-3-泛型方法与可变参数\"><a href=\"#3-4-3-泛型方法与可变参数\" class=\"headerlink\" title=\"3.4.3 泛型方法与可变参数\"></a>3.4.3 泛型方法与可变参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public &lt;T&gt; void printMsg( T... args)&#123;</span><br><span class=\"line\">    for(T t : args)&#123;</span><br><span class=\"line\">        Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//...</span><br><span class=\"line\">printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-4-4-静态方法与泛型\"><a href=\"#3-4-4-静态方法与泛型\" class=\"headerlink\" title=\"3.4.4 静态方法与泛型\"></a>3.4.4 静态方法与泛型</h4><p>注意：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p>\n<p>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StaticGenerator&lt;T&gt; &#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span><br><span class=\"line\">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span><br><span class=\"line\">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span><br><span class=\"line\">          &quot;StaticGenerator cannot be refrenced from static context&quot;</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static &lt;T&gt; void show(T t)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-4-5-泛型方法总结\"><a href=\"#3-4-5-泛型方法总结\" class=\"headerlink\" title=\"3.4.5 泛型方法总结\"></a>3.4.5 泛型方法总结</h4><blockquote>\n<p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</p>\n</blockquote>\n<h3 id=\"3-5-泛型上下边界\"><a href=\"#3-5-泛型上下边界\" class=\"headerlink\" title=\"3.5 泛型上下边界\"></a>3.5 泛型上下边界</h3><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>\n<h4 id=\"为泛型添加上边界，即传入的类型实参必须是指定类型的子类型\"><a href=\"#为泛型添加上边界，即传入的类型实参必须是指定类型的子类型\" class=\"headerlink\" title=\"为泛型添加上边界，即传入的类型实参必须是指定类型的子类型\"></a>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;</span><br><span class=\"line\">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);</span><br><span class=\"line\">Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);</span><br><span class=\"line\">Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);</span><br><span class=\"line\">Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);</span><br><span class=\"line\"></span><br><span class=\"line\">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</span><br><span class=\"line\">//showKeyValue1(generic1);</span><br><span class=\"line\"></span><br><span class=\"line\">showKeyValue1(generic2);</span><br><span class=\"line\">showKeyValue1(generic3);</span><br><span class=\"line\">showKeyValue1(generic4);</span><br></pre></td></tr></table></figure>\n<p><strong>泛型的上下边界添加，必须与泛型的声明在一起 。</strong></p>\n<h3 id=\"3-6-泛型数组\"><a href=\"#3-6-泛型数组\" class=\"headerlink\" title=\"3.6 泛型数组\"></a>3.6 泛型数组</h3><p>sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。</p>\n<p>下面的这个例子是不可以的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];</span><br></pre></td></tr></table></figure></p>\n<p>而使用通配符创建泛型数组是可以的，如下面这个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10];</span><br></pre></td></tr></table></figure></p>\n<p>下面的也行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt;[] ls = new ArrayList[10];</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html\" target=\"_blank\" rel=\"noopener\">sun公司文档说明</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed.    </span><br><span class=\"line\">Object o = lsa;    </span><br><span class=\"line\">Object[] oa = (Object[]) o;    </span><br><span class=\"line\">List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    </span><br><span class=\"line\">li.add(new Integer(3));    </span><br><span class=\"line\">oa[1] = li; // Unsound, but passes run time store check    </span><br><span class=\"line\">String s = lsa[1].get(0); // Run-time error: ClassCastException.</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa<a href=\"http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html\" target=\"_blank\" rel=\"noopener\">1</a>赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p>\n</blockquote>\n<blockquote>\n<p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p>\n</blockquote>\n<p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量</strong>，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type.    </span><br><span class=\"line\">Object o = lsa;    </span><br><span class=\"line\">Object[] oa = (Object[]) o;    </span><br><span class=\"line\">List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    </span><br><span class=\"line\">li.add(new Integer(3));    </span><br><span class=\"line\">oa[1] = li; // Correct.    </span><br><span class=\"line\">Integer i = (Integer) lsa[1].get(0); // OK</span><br></pre></td></tr></table></figure></p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、什么是泛型？\"><a href=\"#一、什么是泛型？\" class=\"headerlink\" title=\"一、什么是泛型？\"></a>一、什么是泛型？</h2><blockquote>\n<p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>\n</blockquote>\n<blockquote>\n<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>\n</blockquote>\n<h2 id=\"二、泛型特性\"><a href=\"#二、泛型特性\" class=\"headerlink\" title=\"二、泛型特性\"></a>二、泛型特性</h2><p>泛型只在编译阶段有效。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>\n<p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>\n<h2 id=\"三、泛型的使用\"><a href=\"#三、泛型的使用\" class=\"headerlink\" title=\"三、泛型的使用\"></a>三、泛型的使用</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>\n<h3 id=\"3-1-泛型类\"><a href=\"#3-1-泛型类\" class=\"headerlink\" title=\"3.1 泛型类\"></a>3.1 泛型类</h3><p>通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;</span><br><span class=\"line\">  private 泛型标识 /*（成员变量类型）*/ var; </span><br><span class=\"line\">  .....</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个简单的泛型类：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class=\"line\">//在实例化泛型类时，必须指定T的具体类型</span><br><span class=\"line\">public class Generic&lt;T&gt;&#123; </span><br><span class=\"line\">    //key这个成员变量的类型为T,T的类型由外部指定  </span><br><span class=\"line\">    private T key;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定</span><br><span class=\"line\">        this.key = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定</span><br><span class=\"line\">        return key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span><br><span class=\"line\">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span><br><span class=\"line\">Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</span><br><span class=\"line\"></span><br><span class=\"line\">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span><br><span class=\"line\">Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);</span><br><span class=\"line\">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());</span><br><span class=\"line\">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>泛型的类型参数只能是类类型，不能是简单类型。</li>\n<li>不能对确切的泛型类型使用instanceof操作。</li>\n</ol>\n<h3 id=\"3-2-泛型接口\"><a href=\"#3-2-泛型接口\" class=\"headerlink\" title=\"3.2 泛型接口\"></a>3.2 泛型接口</h3><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义一个泛型接口</span><br><span class=\"line\">public interface Generator&lt;T&gt; &#123;</span><br><span class=\"line\">    public T next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当实现泛型接口的类，未传入泛型实参时：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span><br><span class=\"line\"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;</span><br><span class=\"line\"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public T next() &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当实现泛型接口的类，传入泛型实参时：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 传入泛型实参时：</span><br><span class=\"line\"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span><br><span class=\"line\"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span><br><span class=\"line\"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span><br><span class=\"line\"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String next() &#123;</span><br><span class=\"line\">        Random rand = new Random();</span><br><span class=\"line\">        return fruits[rand.nextInt(3)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-3-泛型通配符\"><a href=\"#3-3-泛型通配符\" class=\"headerlink\" title=\"3.3 泛型通配符\"></a>3.3 泛型通配符</h3><p><strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;</span><br><span class=\"line\">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>类型通配符一般是使用？代替具体的<strong>类型实参</strong>，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p>\n<p>可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p>\n<h3 id=\"3-4-泛型方法\"><a href=\"#3-4-泛型方法\" class=\"headerlink\" title=\"3.4 泛型方法\"></a>3.4 泛型方法</h3><p>泛型方法比上面提到的泛型类要复杂的多</p>\n<p>需要注意的是：<strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 泛型方法的基本介绍</span><br><span class=\"line\"> * @param tClass 传入的泛型实参</span><br><span class=\"line\"> * @return T 返回值为T类型</span><br><span class=\"line\"> * 说明：</span><br><span class=\"line\"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span><br><span class=\"line\"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span><br><span class=\"line\"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span><br><span class=\"line\"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span><br><span class=\"line\"> */</span><br><span class=\"line\">public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,</span><br><span class=\"line\">  IllegalAccessException&#123;</span><br><span class=\"line\">        T instance = tClass.newInstance();</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = genericMethod(Class.forName(&quot;com.test.test&quot;));</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-4-1-泛型方法的基本使用\"><a href=\"#3-4-1-泛型方法的基本使用\" class=\"headerlink\" title=\"3.4.1 泛型方法的基本使用\"></a>3.4.1 泛型方法的基本使用</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GenericTest &#123;</span><br><span class=\"line\">   //这个类是个泛型类，在上面已经介绍过</span><br><span class=\"line\">   public class Generic&lt;T&gt;&#123;     </span><br><span class=\"line\">        private T key;</span><br><span class=\"line\"></span><br><span class=\"line\">        public Generic(T key) &#123;</span><br><span class=\"line\">            this.key = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span><br><span class=\"line\">        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span><br><span class=\"line\">        //所以在这个方法中才可以继续使用 T 这个泛型。</span><br><span class=\"line\">        public T getKey()&#123;</span><br><span class=\"line\">            return key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;</span><br><span class=\"line\">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span><br><span class=\"line\">        public E setKey(E key)&#123;</span><br><span class=\"line\">             this.key = keu</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        */</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /** </span><br><span class=\"line\">     * 这才是一个真正的泛型方法。</span><br><span class=\"line\">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span><br><span class=\"line\">     * 这个T可以出现在这个泛型方法的任意位置.</span><br><span class=\"line\">     * 泛型的数量也可以为任意多个 </span><br><span class=\"line\">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class=\"line\">     *        ...</span><br><span class=\"line\">     *        &#125;</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class=\"line\">        System.out.println(&quot;container key :&quot; + container.getKey());</span><br><span class=\"line\">        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span><br><span class=\"line\">        T test = container.getKey();</span><br><span class=\"line\">        return test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span><br><span class=\"line\">    public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</span><br><span class=\"line\">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span><br><span class=\"line\">    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span><br><span class=\"line\">    public void showKeyValue2(Generic&lt;?&gt; obj)&#123;</span><br><span class=\"line\">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     /**</span><br><span class=\"line\">     * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &apos;E&apos; &quot;</span><br><span class=\"line\">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span><br><span class=\"line\">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span><br><span class=\"line\">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    */</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &apos;T&apos; &quot;</span><br><span class=\"line\">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span><br><span class=\"line\">     * 所以这也不是一个正确的泛型方法声明。</span><br><span class=\"line\">    public void showkey(T genericObj)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    */</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-4-2-类中的泛型方法\"><a href=\"#3-4-2-类中的泛型方法\" class=\"headerlink\" title=\"3.4.2 类中的泛型方法\"></a>3.4.2 类中的泛型方法</h4><p>泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GenericFruit &#123;</span><br><span class=\"line\">    class Fruit&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;fruit&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Apple extends Fruit&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;apple&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Person&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;Person&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class GenerateTest&lt;T&gt;&#123;</span><br><span class=\"line\">        public void show_1(T t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span><br><span class=\"line\">        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span><br><span class=\"line\">        public &lt;E&gt; void show_3(E t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span><br><span class=\"line\">        public &lt;T&gt; void show_2(T t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Apple apple = new Apple();</span><br><span class=\"line\">        Person person = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();</span><br><span class=\"line\">        //apple是Fruit的子类，所以这里可以</span><br><span class=\"line\">        generateTest.show_1(apple);</span><br><span class=\"line\">        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span><br><span class=\"line\">        //generateTest.show_1(person);</span><br><span class=\"line\"></span><br><span class=\"line\">        //使用这两个方法都可以成功</span><br><span class=\"line\">        generateTest.show_2(apple);</span><br><span class=\"line\">        generateTest.show_2(person);</span><br><span class=\"line\"></span><br><span class=\"line\">        //使用这两个方法也都可以成功</span><br><span class=\"line\">        generateTest.show_3(apple);</span><br><span class=\"line\">        generateTest.show_3(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-4-3-泛型方法与可变参数\"><a href=\"#3-4-3-泛型方法与可变参数\" class=\"headerlink\" title=\"3.4.3 泛型方法与可变参数\"></a>3.4.3 泛型方法与可变参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public &lt;T&gt; void printMsg( T... args)&#123;</span><br><span class=\"line\">    for(T t : args)&#123;</span><br><span class=\"line\">        Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//...</span><br><span class=\"line\">printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-4-4-静态方法与泛型\"><a href=\"#3-4-4-静态方法与泛型\" class=\"headerlink\" title=\"3.4.4 静态方法与泛型\"></a>3.4.4 静态方法与泛型</h4><p>注意：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p>\n<p>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StaticGenerator&lt;T&gt; &#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span><br><span class=\"line\">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span><br><span class=\"line\">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span><br><span class=\"line\">          &quot;StaticGenerator cannot be refrenced from static context&quot;</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static &lt;T&gt; void show(T t)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-4-5-泛型方法总结\"><a href=\"#3-4-5-泛型方法总结\" class=\"headerlink\" title=\"3.4.5 泛型方法总结\"></a>3.4.5 泛型方法总结</h4><blockquote>\n<p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</p>\n</blockquote>\n<h3 id=\"3-5-泛型上下边界\"><a href=\"#3-5-泛型上下边界\" class=\"headerlink\" title=\"3.5 泛型上下边界\"></a>3.5 泛型上下边界</h3><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>\n<h4 id=\"为泛型添加上边界，即传入的类型实参必须是指定类型的子类型\"><a href=\"#为泛型添加上边界，即传入的类型实参必须是指定类型的子类型\" class=\"headerlink\" title=\"为泛型添加上边界，即传入的类型实参必须是指定类型的子类型\"></a>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;</span><br><span class=\"line\">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);</span><br><span class=\"line\">Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);</span><br><span class=\"line\">Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);</span><br><span class=\"line\">Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);</span><br><span class=\"line\"></span><br><span class=\"line\">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</span><br><span class=\"line\">//showKeyValue1(generic1);</span><br><span class=\"line\"></span><br><span class=\"line\">showKeyValue1(generic2);</span><br><span class=\"line\">showKeyValue1(generic3);</span><br><span class=\"line\">showKeyValue1(generic4);</span><br></pre></td></tr></table></figure>\n<p><strong>泛型的上下边界添加，必须与泛型的声明在一起 。</strong></p>\n<h3 id=\"3-6-泛型数组\"><a href=\"#3-6-泛型数组\" class=\"headerlink\" title=\"3.6 泛型数组\"></a>3.6 泛型数组</h3><p>sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。</p>\n<p>下面的这个例子是不可以的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];</span><br></pre></td></tr></table></figure></p>\n<p>而使用通配符创建泛型数组是可以的，如下面这个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10];</span><br></pre></td></tr></table></figure></p>\n<p>下面的也行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt;[] ls = new ArrayList[10];</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html\" target=\"_blank\" rel=\"noopener\">sun公司文档说明</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed.    </span><br><span class=\"line\">Object o = lsa;    </span><br><span class=\"line\">Object[] oa = (Object[]) o;    </span><br><span class=\"line\">List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    </span><br><span class=\"line\">li.add(new Integer(3));    </span><br><span class=\"line\">oa[1] = li; // Unsound, but passes run time store check    </span><br><span class=\"line\">String s = lsa[1].get(0); // Run-time error: ClassCastException.</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa<a href=\"http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html\" target=\"_blank\" rel=\"noopener\">1</a>赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p>\n</blockquote>\n<blockquote>\n<p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p>\n</blockquote>\n<p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量</strong>，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type.    </span><br><span class=\"line\">Object o = lsa;    </span><br><span class=\"line\">Object[] oa = (Object[]) o;    </span><br><span class=\"line\">List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    </span><br><span class=\"line\">li.add(new Integer(3));    </span><br><span class=\"line\">oa[1] = li; // Correct.    </span><br><span class=\"line\">Integer i = (Integer) lsa[1].get(0); // OK</span><br></pre></td></tr></table></figure></p>\n<hr>\n"},{"title":"工作随记-4月4周目","date":"2018-04-27T05:35:51.000Z","_content":"\n## Android CircleImageView\n\nA fast circular ImageView perfect for profile images. \n[CircleImageView Github][1]\n\n![CircleImageView][2]\n\n----------\n\n\n\n-------------------------------------------------------------\n\n  [1]: https://github.com/hdodenhof/CircleImageView\n  [2]: https://camo.githubusercontent.com/e17a2a83e3e205a822d27172cb3736d4f441344d/68747470733a2f2f7261772e6769746875622e636f6d2f68646f64656e686f662f436972636c65496d616765566965772f6d61737465722f73637265656e73686f742e706e67","source":"_posts/others/工作随记-4月4周.md","raw":"---\ntitle: 工作随记-4月4周目\ndate: 2018-04-27 13:35:51\ntags: \ncategories:\n    - 工作\n---\n\n## Android CircleImageView\n\nA fast circular ImageView perfect for profile images. \n[CircleImageView Github][1]\n\n![CircleImageView][2]\n\n----------\n\n\n\n-------------------------------------------------------------\n\n  [1]: https://github.com/hdodenhof/CircleImageView\n  [2]: https://camo.githubusercontent.com/e17a2a83e3e205a822d27172cb3736d4f441344d/68747470733a2f2f7261772e6769746875622e636f6d2f68646f64656e686f662f436972636c65496d616765566965772f6d61737465722f73637265656e73686f742e706e67","slug":"others/工作随记-4月4周","published":1,"updated":"2018-04-27T08:04:58.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgwypwxe0009os6xzirbhljt","content":"<h2 id=\"Android-CircleImageView\"><a href=\"#Android-CircleImageView\" class=\"headerlink\" title=\"Android CircleImageView\"></a>Android CircleImageView</h2><p>A fast circular ImageView perfect for profile images.<br><a href=\"https://github.com/hdodenhof/CircleImageView\" target=\"_blank\" rel=\"noopener\">CircleImageView Github</a></p>\n<p><img src=\"https://camo.githubusercontent.com/e17a2a83e3e205a822d27172cb3736d4f441344d/68747470733a2f2f7261772e6769746875622e636f6d2f68646f64656e686f662f436972636c65496d616765566965772f6d61737465722f73637265656e73686f742e706e67\" alt=\"CircleImageView\"></p>\n<hr>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android-CircleImageView\"><a href=\"#Android-CircleImageView\" class=\"headerlink\" title=\"Android CircleImageView\"></a>Android CircleImageView</h2><p>A fast circular ImageView perfect for profile images.<br><a href=\"https://github.com/hdodenhof/CircleImageView\" target=\"_blank\" rel=\"noopener\">CircleImageView Github</a></p>\n<p><img src=\"https://camo.githubusercontent.com/e17a2a83e3e205a822d27172cb3736d4f441344d/68747470733a2f2f7261772e6769746875622e636f6d2f68646f64656e686f662f436972636c65496d616765566965772f6d61737465722f73637265656e73686f742e706e67\" alt=\"CircleImageView\"></p>\n<hr>\n<hr>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjgwypwx20000os6xk44pb70x","category_id":"cjgwypwx90003os6x8davowm7","_id":"cjgwypwxc0007os6xw12awo8a"},{"post_id":"cjgwypwx70002os6xqywzzyj8","category_id":"cjgwypwxb0005os6xuehnyg1c","_id":"cjgwypwxc0008os6xrvk9q07x"},{"post_id":"cjgwypwxe0009os6xzirbhljt","category_id":"cjgwypwxf000aos6xtw0857sd","_id":"cjgwypwxf000bos6x4b1cu9zu"}],"PostTag":[{"post_id":"cjgwypwx70002os6xqywzzyj8","tag_id":"cjgwypwxb0004os6x1lf1sajo","_id":"cjgwypwxc0006os6xovvx63ia"}],"Tag":[{"name":"java","_id":"cjgwypwxb0004os6x1lf1sajo"}]}}